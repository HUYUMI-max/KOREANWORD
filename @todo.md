# プロジェクトのTODOリスト

## 優先度：高
- [ ] プロジェクトの基本構造の確認と整理
- [ ] 必要なコンポーネントの実装
- [ ] データベース設計と実装
- [ ] 認証機能の実装

## 優先度：中
- [ ] UI/UXの改善
- [ ] パフォーマンス最適化
- [ ] エラーハンドリングの実装
- [ ] テストの実装

## 優先度：低
- [ ] ドキュメントの整備
- [ ] コードのリファクタリング
- [ ] デプロイメント設定の確認

## 注意事項
- セキュリティ面での考慮が必要
- ユーザビリティの向上に注力
- パフォーマンスの最適化を意識

GET使ってるファイル
src\app\api\folders\route.ts
src\app\api\folders\[folderName]\words\route.ts

sidebarで使っている？　クライアント
wordActions.tsで使っている？　クライアント
folderAction.tsで使っている？　クライアント

## お気に入り機能の問題追跡

### 解決済みの問題
- [x] Firebaseの単語の星マークをクリックしてもすぐにUIに反映されない（ページ更新で反映）
  - SWRの設定更新と状態管理の改善により解決

### 現在の問題
- [ ] 🔴 お気に入り状態変更時の位置管理の問題
  - 発生条件：2番目以降の単語をお気に入り状態に変更時
  - 症状：
    1. 最初の単語に戻ってしまう
    2. シャッフル状態が解除される
  - 影響：単語数が多い場合の使い勝手が悪化
  - 優先度：高（即時対応が必要）

- [ ] 🟡 お気に入り状態変更時に一瞬単語が消える
  - 発生条件：Firebaseの単語をお気に入り状態に変更時
  - 影響：一瞬の表示問題で、ユーザー体験への影響は限定的
  - 優先度：中（後日対応可能）

### 考えられる原因
1. 状態更新の順序とタイミング
   - `mutate`と`setCards`の実行順序による問題
   - `filteredCards`の更新タイミングと`index`の同期が取れていない
   - シャッフル状態の管理が適切に行われていない

2. 一瞬の表示問題
   - 楽観的UI更新と実際のデータ更新の間のタイミング
   - 状態更新の順序による一時的な不整合

### 次の調査ステップ
1. 状態管理の改善
   - `filteredCards`の更新タイミングの見直し
   - シャッフル状態の保持方法の検討
   - 状態更新の順序の最適化

2. インデックス管理の修正
   - 現在の単語の位置を維持する方法の再検討
   - シャッフル状態を考慮した位置管理の実装
   - 状態更新時の位置計算ロジックの改善

### 実施した修正
1. SWRの設定更新
   - revalidateOnFocus: true を追加
   - revalidateOnReconnect: true を追加
   - dedupingInterval: 2000 を追加

2. 状態管理の改善
   - 楽観的UI更新の実装
   - 強制的な再検証の追加
   - 状態の強制更新の実装
   - インデックス保持の試行（未解決）

### 今後の対応方針
1. 状態管理の完全な見直し
   - シャッフル状態の保持方法の改善
   - 状態更新の順序の最適化
   - インデックス管理の再実装

2. 表示問題の改善（優先度低）
   - 状態更新の順序の見直し
   - 必要に応じてUIの改善

## ビルドエラーの履歴と対応状況

### 2024-03-XX お気に入り機能のAPIエンドポイント修正

#### 発生したエラー
1. 最初のエラー
   - ファイル: `src/app/api/folders/[folderName]/words/[wordId]/favorite/route.ts`
   - エラー内容: 型定義の不一致（`params`の型が`Promise<any>`を要求）
   - 対応: `RouteContext`型を追加し、パラメータの受け取り方を修正

2. 2回目のエラー
   - 同じファイルで型エラーが継続
   - エラー内容: `ParamCheck<RouteContext>`の制約を満たしていない
   - 対応: カスタム型を削除し、直接パラメータを受け取る形に修正

3. 3回目のエラー
   - 同じファイルで型エラーが継続
   - 対応: 他のAPIエンドポイントを参考に`context: any`を使用する形に修正
   - 変更内容：
     - `context`パラメータの型を`any`に変更
     - `params`の分割代入を`context.params`から行うように変更
     - 戻り値の型指定を削除

#### 現在の状況
- [~] 🟡 ビルドエラーの修正を試行中
- [ ] 🔴 最終的な解決の確認待ち

#### 次の対応方針
1. ビルドを実行して修正の効果を確認
2. 必要に応じて他のAPIエンドポイントの実装も同様に修正
3. 型安全性を確保するための長期的な改善計画の検討

#### 注意点
- 型エラーの解決には、Next.jsのバージョンに応じた正確な型定義が必要
- APIエンドポイントの実装は、App Routerの仕様に完全に準拠する必要がある
- `any`型の使用は一時的な解決策であり、将来的にはより型安全な実装を検討する必要がある

## 今回のブランチでの変更内容

### お気に入り機能の実装

#### 実装した機能
1. お気に入り状態の管理
   - `Flashcard`型に`isFavorite`フィールドを追加
   - お気に入り状態の切り替え機能を実装
   - お気に入りのみ表示フィルター機能を追加

2. データ永続化
   - Firebaseモード：Firestoreに`isFavorite`状態を保存
   - レベルモード：localStorageに`isFavorite`状態を保存

3. UI実装
   - お気に入りボタン（★/☆）の追加
   - お気に入りフィルターボタンの追加
   - 状態変更時のアニメーション効果

#### 対応した問題
1. お気に入り状態の即時反映
   - SWRの設定を最適化（revalidateOnFocus, revalidateOnReconnect）
   - 楽観的UI更新の実装
   - 状態管理の改善

2. ビルドエラー
   - Next.jsのApp Routerの型定義に合わせた修正
   - APIエンドポイントの型エラーを解消

#### 残っている課題
1. お気に入り状態変更時の位置管理
   - 2番目以降の単語をお気に入り状態に変更時に最初の単語に戻る問題
   - シャッフル状態が解除される問題

2. 表示の一時的な問題
   - お気に入り状態変更時に一瞬単語が消える問題

#### 次のステップ
1. 位置管理の問題の解決
   - 現在の単語の位置を維持する機能の実装
   - シャッフル状態の保持方法の改善

2. 表示問題の改善
   - 状態更新の順序の最適化
   - UIの改善（必要に応じて）

3. 型安全性の向上
   - APIエンドポイントの型定義の改善
   - より型安全な実装への移行

## 状態管理の根本的な見直し計画

### 現状の問題点
1. 状態の同期問題
   - お気に入り状態変更時に位置がリセットされる
   - シャッフル状態が保持されない
   - 状態更新の順序による一時的な表示問題

2. 状態管理の複雑さ
   - 複数の状態（cards, index, shuffle, favorite）が相互に影響
   - 状態更新のタイミングが適切に制御されていない
   - 楽観的UI更新と実際のデータ更新の同期が不完全

### 改善計画

#### 1. 状態の整理と統合
- [ ] 状態の一元管理
  ```typescript
  type FlashcardState = {
    cards: Flashcard[]
    currentIndex: number
    isShuffled: boolean
    originalOrder: number[]  // シャッフル前の順序を保持
  }
  ```
- [ ] 状態更新の統一インターフェース
  ```typescript
  type StateAction = 
    | { type: 'TOGGLE_FAVORITE'; wordId: string }
    | { type: 'SHUFFLE' }
    | { type: 'RESET_ORDER' }
    | { type: 'SET_INDEX'; index: number }
  ```

#### 2. シャッフル状態の保持
- [ ] シャッフル状態の永続化
  - シャッフル時の順序マッピングを保持
  - 状態更新時に順序マッピングを維持
- [ ] シャッフル状態の復元機能
  - ページリロード時もシャッフル状態を維持
  - お気に入り状態変更時もシャッフル状態を保持

#### 3. 状態更新の最適化
- [ ] 更新の順序制御
  ```typescript
  async function handleStateUpdate(action: StateAction) {
    // 1. 楽観的UI更新
    const optimisticState = updateStateOptimistically(state, action)
    setState(optimisticState)

    try {
      // 2. バックエンド更新
      await updateBackend(action)
      
      // 3. 状態の確定
      setState(prev => ({
        ...prev,
        isUpdating: false
      }))
    } catch (error) {
      // 4. エラー時の状態復元
      setState(prev => ({
        ...prev,
        ...state,
        isUpdating: false
      }))
    }
  }
  ```

#### 4. インデックス管理の改善
- [ ] インデックスの永続化
  - 現在のインデックスを状態の一部として管理
  - 状態更新時にインデックスを維持
- [ ] インデックスの検証
  - 範囲外のインデックスを自動補正
  - フィルター適用時のインデックス調整

### 実装ステップ
1. 状態管理のリファクタリング
   - [ ] 新しい状態型の定義
   - [ ] 状態更新ロジックの実装
   - [ ] 既存コードの移行

2. シャッフル機能の改善
   - [ ] 順序マッピングの実装
   - [ ] シャッフル状態の永続化
   - [ ] 状態更新時の順序維持

3. お気に入り機能の改善
   - [ ] 状態更新の最適化
   - [ ] エラーハンドリングの強化
   - [ ] UIの改善

### 期待される効果
1. 状態の一貫性向上
   - お気に入り状態変更時の位置維持
   - シャッフル状態の保持
   - 表示の安定性向上

2. パフォーマンスの改善
   - 不要な再レンダリングの削減
   - 状態更新の効率化
   - メモリ使用量の最適化

3. コードの保守性向上
   - 状態管理の一元化
   - 型安全性の向上
   - テストのしやすさ

## お気に入り機能の問題追跡（追加記録）

### 新たな・継続中の問題
- [ ] 2番目以降のカードをお気に入りにすると1番目に戻る
- [ ] シャッフル状態でお気に入りを押すとエラーは出ないが、シャッフルが解除される

### 考えられる原因
- currentIndexの復元ロジックが不十分（カード配列の再構築時にインデックスが正しく再計算されていない）
- safeShuffledCardsやupdatedWordsの内容とshuffledIndicesの整合性が崩れている
- SET_CARDSアクションでcurrentIndexが常に0にリセットされているため、dispatch({ type: 'SET_INDEX', ... })が意図通りに動作していない可能性
- シャッフル状態の維持ロジックが不完全（shuffledIndicesやisShuffledの再設定が抜けている）

### やってダメだったこと
- SET_CARDSでcurrentIndexを0にリセットし、後からSET_INDEXで復元しようとしたが、状態の競合や非同期のタイミングでうまくいかない
- mutateの戻り値やstate.cardsの内容を使ってfindIndexで復元しようとしたが、配列の内容が変化しているため正しいインデックスが得られない場合がある
- safeShuffledCardsやupdatedWordsのfilter/mapでundefinedを除外した結果、インデックスがずれることがある

### 今後の方針
- SET_CARDSアクションでcurrentIndexを0にリセットしないようにし、dispatch({ type: 'SET_INDEX', ... })で正しいインデックスを必ずセットする
- シャッフル状態の維持には、cards・shuffledIndices・isShuffledを一貫して管理する
- SET_CARDSアクションにcurrentIndexを渡せるようにする、またはSET_CARDSとSET_INDEXをまとめて1つのアクションで管理する
- 状態更新の順序と非同期処理のタイミングを見直す

### 直近の修正内容と結果（2024-05-09）
- SET_CARDSアクションを拡張し、cards・currentIndex・isShuffled・shuffledIndicesを一括で管理するように修正
- お気に入り更新時も、シャッフル状態やインデックスが崩れないように一括でdispatchするよう変更
- → どちらの問題（1番目に戻る／シャッフル解除）も解消せず、現象は継続

### 新たな気づき・やってダメだったこと（2024-05-09追記）
- お気に入り更新時の状態一括更新は正しく動作しているが、「シャッフル解除」や「元の順番」アクションでcurrentIndexが0にリセットされるため、1枚目に戻る現象が発生している。
- シャッフル解除時にも、現在表示中のカードIDを基準に新しい配列でのインデックスを再計算してcurrentIndexをセットする必要がある。

### 次の修正方針
- 「シャッフル解除」や「元の順番」アクション時も、現在表示中のカードIDを基準にcurrentIndexを再計算してdispatchする。
- これにより、「1枚目に戻る」現象を根本的に解消できる見込み。

### やってダメだったこと（2024-05-09追加）
- お気に入り更新時にcurrentIndexやisShuffled, shuffledIndicesを一括で管理しても、SWRの再検証やstateの参照タイミングのズレで状態が維持できない。
- handleToggleFavorite内でstateの値を参照しても、非同期処理やreducerのバッチ処理の影響で意図通りの値が使えない場合がある。
- SET_CARDSアクションの拡張だけでは根本解決にならない。

### 次の調査・修正方針
- お気に入り更新直後のSWR mutate/再検証の影響を最小化する。
- mutate後のcards配列・シャッフル状態・currentIndexを「必ず最新の値で」再計算する。
- stateの値を常に最新で参照するため、useRefでcurrentCardIdやisShuffledを保持し、dispatch時にそれを使う。
- お気に入り更新時のstate更新を「1アクションで」完結させ、SWRの再検証後も同じカード・同じシャッフル状態を維持する。

### 新たな調査・修正方針（2024-05-09追記）
- mutate後の配列をUI順に並び替えても解決しない場合、Firestore/SWRのデータ取得タイミングやキャッシュの問題が根本原因の可能性が高い。
- お気に入り更新APIのレスポンスで「更新後の全単語リスト」を返し、そのままUIに反映する方式を試す。
- SWRのキャッシュ設定（fallbackData, dedupingInterval等）も一時的に外し、キャッシュの影響を排除する。
- cursorルール（dev-rules/nextjs, global, techstack.mdc, db-blueprint等）を厳守し、API設計・型安全・バリデーション・認証も徹底する。